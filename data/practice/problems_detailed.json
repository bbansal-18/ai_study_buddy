{
  "recursion_easy_1": {
    "title": "Factorial of a Number",
    "topic": "recursion",
    "difficulty": "easy",
    "function": "factorial",
    "inputs": [
      "n: int"
    ],
    "return": "int",
    "statement": "Given a non-negative integer n, return n! (the product of all positive integers less than or equal to n). Assume n ≥ 0.",
    "sample_input": "5",
    "sample_output": "120"
  },
  "recursion_moderate_1": {
    "title": "Generate All Subsets (Power Set)",
    "topic": "recursion",
    "difficulty": "moderate",
    "function": "subsets",
    "inputs": [
      "nums: list[int]"
    ],
    "return": "list[list[int]]",
    "statement": "Given a list of distinct integers nums, return all possible subsets (the power set). The solution set must not contain duplicate subsets. You can return subsets in any order.",
    "sample_input": "[1, 2, 3]",
    "sample_output": "[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]"
  },
  "recursion_hard_1": {
    "title": "N-Queens",
    "topic": "recursion",
    "difficulty": "hard",
    "function": "solve_n_queens",
    "inputs": [
      "n: int"
    ],
    "return": "list[list[str]]",
    "statement": "Place n queens on an n×n chessboard so that no two queens attack each other. Return all distinct solutions. Each solution is a list of n strings of length n, where 'Q' indicates a queen and '.' indicates an empty square.",
    "sample_input": "4",
    "sample_output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"], [\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]"
  },
  "dynamic_programming_easy_1": {
    "title": "Climbing Stairs",
    "topic": "dynamic programming",
    "difficulty": "easy",
    "function": "climb_stairs",
    "inputs": [
      "n: int"
    ],
    "return": "int",
    "statement": "You are climbing a staircase with n steps. You can take either 1 or 2 steps at a time. Return how many distinct ways you can climb to the top. For n = 0, return 1 (one way: do nothing).",
    "sample_input": "3",
    "sample_output": "3"
  },
  "dynamic_programming_moderate_1": {
    "title": "Unique Paths",
    "topic": "dynamic programming",
    "difficulty": "moderate",
    "function": "unique_paths",
    "inputs": [
      "m: int",
      "n: int"
    ],
    "return": "int",
    "statement": "A robot is located at the top-left corner of an m×n grid. It can only move down or right. How many unique paths are there from the top-left to the bottom-right corner?",
    "sample_input": "m = 3, n = 2",
    "sample_output": "3"
  },
  "dynamic_programming_hard_1": {
    "title": "Edit Distance",
    "topic": "dynamic programming",
    "difficulty": "hard",
    "function": "min_distance",
    "inputs": [
      "word1: str",
      "word2: str"
    ],
    "return": "int",
    "statement": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 into word2. You have three operations: insert a character, delete a character, or replace a character.",
    "sample_input": "word1 = \"horse\", word2 = \"ros\"",
    "sample_output": "3"
  },
  "graphs_easy_1": {
    "title": "Flood Fill",
    "topic": "graphs",
    "difficulty": "easy",
    "function": "flood_fill",
    "inputs": [
      "image: list[list[int]]",
      "sr: int",
      "sc: int",
      "new_color: int"
    ],
    "return": "list[list[int]]",
    "statement": "Given an m×n array image where each pixel has a color denoted by an integer. Starting from pixel (sr, sc), change the color of all connected pixels (4-directionally) having the same original color to new_color. Return the modified image.",
    "sample_input": "image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, new_color = 2",
    "sample_output": "[[2,2,2],[2,2,0],[2,0,1]]"
  },
  "graphs_moderate_1": {
    "title": "Number of Islands",
    "topic": "graphs",
    "difficulty": "moderate",
    "function": "num_islands",
    "inputs": [
      "grid: list[list[str]]"
    ],
    "return": "int",
    "statement": "Given an m×n grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
    "sample_input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
    "sample_output": "1"
  },
  "graphs_hard_1": {
    "title": "Word Ladder II",
    "topic": "graphs",
    "difficulty": "hard",
    "function": "find_ladders",
    "inputs": [
      "begin_word: str",
      "end_word: str",
      "word_list: list[str]"
    ],
    "return": "list[list[str]]",
    "statement": "Given begin_word, end_word, and a dictionary of words word_list, return all shortest transformation sequences from begin_word to end_word, such that only one letter can be changed at a time and each transformed word must exist in word_list. Return all possible sequences.",
    "sample_input": "begin_word = \"hit\", end_word = \"cog\", word_list = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
    "sample_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"], [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]"
  },
  "linked_lists_easy_1": {
    "title": "Reverse Linked List",
    "topic": "linked lists",
    "difficulty": "easy",
    "function": "reverse_list",
    "inputs": [
      "head: ListNode"
    ],
    "return": "ListNode",
    "statement": "Given the head of a singly linked list, reverse the list and return the new head.",
    "sample_input": "1 -> 2 -> 3 -> 4 -> 5 -> None",
    "sample_output": "5 -> 4 -> 3 -> 2 -> 1 -> None"
  },
  "linked_lists_moderate_1": {
    "title": "Linked List Cycle II",
    "topic": "linked lists",
    "difficulty": "moderate",
    "function": "detect_cycle",
    "inputs": [
      "head: ListNode"
    ],
    "return": "ListNode",
    "statement": "Given a linked list, return the node where the cycle begins. If there is no cycle, return None. Use O(1) memory.",
    "sample_input": "3 -> 2 -> 0 -> -4, tail connects to node index 1 (value 2)",
    "sample_output": "Node with val = 2"
  },
  "linked_lists_hard_1": {
    "title": "Merge k Sorted Lists",
    "topic": "linked lists",
    "difficulty": "hard",
    "function": "merge_k_lists",
    "inputs": [
      "lists: List[ListNode]"
    ],
    "return": "ListNode",
    "statement": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.",
    "sample_input": "lists = [1->4->5, 1->3->4, 2->6]",
    "sample_output": "1->1->2->3->4->4->5->6"
  },
  "arrays_easy_1": {
    "title": "Two Sum",
    "topic": "arrays",
    "difficulty": "easy",
    "function": "two_sum",
    "inputs": [
      "nums: list[int]",
      "target: int"
    ],
    "return": "list[int]",
    "statement": "Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target. Assume exactly one solution and you may not use the same element twice.",
    "sample_input": "nums = [2,7,11,15], target = 9",
    "sample_output": "[0,1]"
  },
  "arrays_moderate_1": {
    "title": "3Sum",
    "topic": "arrays",
    "difficulty": "moderate",
    "function": "three_sum",
    "inputs": [
      "nums: list[int]"
    ],
    "return": "list[list[int]]",
    "statement": "Given an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that they sum to 0. The solution set must not contain duplicate triplets.",
    "sample_input": "nums = [-1,0,1,2,-1,-4]",
    "sample_output": "[[-1,-1,2],[-1,0,1]]"
  },
  "arrays_hard_1": {
    "title": "First Missing Positive",
    "topic": "arrays",
    "difficulty": "hard",
    "function": "first_missing_positive",
    "inputs": [
      "nums: list[int]"
    ],
    "return": "int",
    "statement": "Given an unsorted integer array nums, find the smallest missing positive integer. Must run in O(n) time and use constant extra space.",
    "sample_input": "nums = [3,4,-1,1]",
    "sample_output": "2"
  },
  "binary_trees_easy_1": {
    "title": "Maximum Depth of Binary Tree",
    "topic": "binary trees",
    "difficulty": "easy",
    "function": "max_depth",
    "inputs": [
      "root: TreeNode"
    ],
    "return": "int",
    "statement": "Given the root of a binary tree, return its maximum depth (the number of nodes along the longest path from the root node down to the farthest leaf node).",
    "sample_input": "root = [3,9,20,null,null,15,7]",
    "sample_output": "3"
  },
  "binary_trees_moderate_1": {
    "title": "Binary Tree Level Order Traversal",
    "topic": "binary trees",
    "difficulty": "moderate",
    "function": "level_order",
    "inputs": [
      "root: TreeNode"
    ],
    "return": "List[List[int]]",
    "statement": "Given the root of a binary tree, return the level order traversal of its nodes’ values (i.e., from left to right, level by level).",
    "sample_input": "root = [3,9,20,null,null,15,7]",
    "sample_output": "[[3],[9,20],[15,7]]"
  },
  "binary_trees_hard_1": {
    "title": "Binary Tree Maximum Path Sum",
    "topic": "binary trees",
    "difficulty": "hard",
    "function": "max_path_sum",
    "inputs": [
      "root: TreeNode"
    ],
    "return": "int",
    "statement": "Given a non-empty binary tree, return the maximum path sum. A path is any sequence of nodes from some starting node to any node in the tree along parent-child connections. The path must contain at least one node.",
    "sample_input": "root = [-10,9,20,null,null,15,7]",
    "sample_output": "42"
  },
  "sorting_easy_1": {
    "title": "Implement Bubble Sort",
    "topic": "sorting",
    "difficulty": "easy",
    "function": "bubble_sort",
    "inputs": [
      "arr: list[int]"
    ],
    "return": "list[int]",
    "statement": "Given a list of integers arr, implement bubble sort and return the sorted list in ascending order.",
    "sample_input": "arr = [5,2,9,1,5,6]",
    "sample_output": "[1,2,5,5,6,9]"
  },
  "sorting_moderate_1": {
    "title": "Merge Sort",
    "topic": "sorting",
    "difficulty": "moderate",
    "function": "merge_sort",
    "inputs": [
      "arr: list[int]"
    ],
    "return": "list[int]",
    "statement": "Implement merge sort on the input list arr and return a new sorted list in ascending order.",
    "sample_input": "arr = [38,27,43,3,9,82,10]",
    "sample_output": "[3,9,10,27,38,43,82]"
  },
  "sorting_hard_1": {
    "title": "Sort Colors (Dutch National Flag)",
    "topic": "sorting",
    "difficulty": "hard",
    "function": "sort_colors",
    "inputs": [
      "nums: list[int]"
    ],
    "return": "None",
    "statement": "Given an array nums with n objects colored red, white, or blue (represented by 0, 1, and 2), sort them in-place so that objects of the same color are adjacent, in the order 0, 1, and 2. Must do it in one pass (O(n) time) and constant space.",
    "sample_input": "nums = [2,0,2,1,1,0]",
    "sample_output": "[0,0,1,1,2,2]"
  },
  "searching_easy_1": {
    "title": "Binary Search",
    "topic": "searching",
    "difficulty": "easy",
    "function": "binary_search",
    "inputs": [
      "nums: list[int]",
      "target: int"
    ],
    "return": "int",
    "statement": "Given a sorted list of distinct integers nums and a target value, return its index if found. Otherwise, return -1. Implement binary search.",
    "sample_input": "nums = [-1,0,3,5,9,12], target = 9",
    "sample_output": "4"
  },
  "searching_moderate_1": {
    "title": "Search in Rotated Sorted Array",
    "topic": "searching",
    "difficulty": "moderate",
    "function": "search_rotated",
    "inputs": [
      "nums: list[int]",
      "target: int"
    ],
    "return": "int",
    "statement": "Suppose an array nums is sorted in ascending order and then rotated at some pivot unknown to you beforehand. If target exists, return its index. Otherwise, return -1. Must run in O(log n) time.",
    "sample_input": "nums = [4,5,6,7,0,1,2], target = 0",
    "sample_output": "4"
  },
  "searching_hard_1": {
    "title": "Median of Two Sorted Arrays",
    "topic": "searching",
    "difficulty": "hard",
    "function": "find_median_sorted_arrays",
    "inputs": [
      "nums1: list[int]",
      "nums2: list[int]"
    ],
    "return": "float",
    "statement": "Given two sorted arrays nums1 and nums2 of size m and n, return the median of the two sorted arrays. The overall run time complexity should be O(log(min(m, n))).",
    "sample_input": "nums1 = [1,3], nums2 = [2]",
    "sample_output": "2.0"
  },
  "hashmaps_easy_1": {
    "title": "Valid Anagram",
    "topic": "hashmaps",
    "difficulty": "easy",
    "function": "is_anagram",
    "inputs": [
      "s: str",
      "t: str"
    ],
    "return": "bool",
    "statement": "Given two strings s and t, return True if t is an anagram of s, and False otherwise.",
    "sample_input": "s = \"anagram\", t = \"nagaram\"",
    "sample_output": "true"
  },
  "hashmaps_moderate_1": {
    "title": "Group Anagrams",
    "topic": "hashmaps",
    "difficulty": "moderate",
    "function": "group_anagrams",
    "inputs": [
      "strs: list[str]"
    ],
    "return": "list[list[str]]",
    "statement": "Given an array of strings strs, group the anagrams together. You may return the answer in any order.",
    "sample_input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
    "sample_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
  },
  "hashmaps_hard_1": {
    "title": "Substring with Concatenation of All Words",
    "topic": "hashmaps",
    "difficulty": "hard",
    "function": "find_substring",
    "inputs": [
      "s: str",
      "words: list[str]"
    ],
    "return": "list[int]",
    "statement": "You are given a string s and an array of strings words. All the strings of words are of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.",
    "sample_input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
    "sample_output": "[0,9]"
  },
  "stacks_easy_1": {
    "title": "Valid Parentheses",
    "topic": "stacks",
    "difficulty": "easy",
    "function": "is_valid",
    "inputs": [
      "s: str"
    ],
    "return": "bool",
    "statement": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets and in the correct order.",
    "sample_input": "s = \"([{}])\"",
    "sample_output": "true"
  },
  "stacks_moderate_1": {
    "title": "Min Stack",
    "topic": "stacks",
    "difficulty": "moderate",
    "function": "MinStack",
    "inputs": [],
    "return": "class with methods",
    "statement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement class MinStack with methods push(val), pop(), top(), and get_min().",
    "sample_input": "stack = MinStack(); stack.push(-2); stack.push(0); stack.push(-3); stack.get_min(); stack.pop(); stack.top(); stack.get_min();",
    "sample_output": "[-3, 0, -2]"
  },
  "stacks_hard_1": {
    "title": "Largest Rectangle in Histogram",
    "topic": "stacks",
    "difficulty": "hard",
    "function": "largest_rectangle_area",
    "inputs": [
      "heights: list[int]"
    ],
    "return": "int",
    "statement": "Given an array of integers heights representing the histogram\u2019s bar heights where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "sample_input": "heights = [2,1,5,6,2,3]",
    "sample_output": "10"
  },
  "queues_easy_1": {
    "title": "Implement Queue Using Stacks",
    "topic": "queues",
    "difficulty": "easy",
    "function": "MyQueue",
    "inputs": [],
    "return": "class with methods",
    "statement": "Implement a queue using two stacks. The queue should support push(x), pop(), peek(), and empty() operations.",
    "sample_input": "queue = MyQueue(); queue.push(1); queue.push(2); queue.peek(); queue.pop(); queue.empty();",
    "sample_output": "[1, 1, false]"
  },
  "queues_moderate_1": {
    "title": "Design Circular Queue",
    "topic": "queues",
    "difficulty": "moderate",
    "function": "MyCircularQueue",
    "inputs": [
      "k: int"
    ],
    "return": "class with methods",
    "statement": "Design your implementation of the circular queue. The queue should support en_queue(value), de_queue(), front(), rear(), is_empty(), and is_full() in O(1) time.",
    "sample_input": "queue = MyCircularQueue(3); queue.en_queue(1); queue.en_queue(2); queue.en_queue(3); queue.en_queue(4); queue.rear(); queue.is_full(); queue.de_queue(); queue.en_queue(4); queue.rear();",
    "sample_output": "[true, true, true, false, 3, true, true, true, 4]"
  },
  "queues_hard_1": {
    "title": "Sliding Window Maximum",
    "topic": "queues",
    "difficulty": "hard",
    "function": "max_sliding_window",
    "inputs": [
      "nums: list[int]",
      "k: int"
    ],
    "return": "list[int]",
    "statement": "Given an array nums and a number k, return an array of the maximum values of each subarray of length k.",
    "sample_input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
    "sample_output": "[3,3,5,5,6,7]"
  },
  "greedy_algorithms_easy_1": {
    "title": "Best Time to Buy and Sell Stock",
    "topic": "greedy algorithms",
    "difficulty": "easy",
    "function": "max_profit",
    "inputs": [
      "prices: list[int]"
    ],
    "return": "int",
    "statement": "You are given an array prices where prices[i] is the price of a given stock on day i. You want to maximize profit by choosing a single day to buy one stock and a different day in the future to sell it. Return the maximum profit. If you cannot achieve any profit, return 0.",
    "sample_input": "prices = [7,1,5,3,6,4]",
    "sample_output": "5"
  },
  "greedy_algorithms_moderate_1": {
    "title": "Jump Game",
    "topic": "greedy algorithms",
    "difficulty": "moderate",
    "function": "can_jump",
    "inputs": [
      "nums: list[int]"
    ],
    "return": "bool",
    "statement": "Given an array of non-negative integers nums, where each element represents the maximum jump length at that position, determine if you are able to reach the last index starting from the first index.",
    "sample_input": "nums = [2,3,1,1,4]",
    "sample_output": "true"
  },
  "greedy_algorithms_hard_1": {
    "title": "Find Median from Data Stream",
    "topic": "greedy algorithms",
    "difficulty": "hard",
    "function": "MedianFinder",
    "inputs": [],
    "return": "class with methods",
    "statement": "Implement a class MedianFinder that supports two operations: add_num(num: int) and find_median(), which returns the median of all elements so far.",
    "sample_input": "mf = MedianFinder(); mf.add_num(1); mf.add_num(2); mf.find_median(); mf.add_num(3); mf.find_median();",
    "sample_output": "[1.5, 2]"
  },
  "python_syntax_easy_1": {
    "title": "List Comprehension Practice",
    "topic": "python syntax",
    "difficulty": "easy",
    "function": "even_squares",
    "inputs": [
      "nums: list[int]"
    ],
    "return": "list[int]",
    "statement": "Given a list of integers nums, return a new list containing the squares of even numbers in nums using a list comprehension.",
    "sample_input": "nums = [1,2,3,4,5]",
    "sample_output": "[4,16]"
  },
  "python_syntax_moderate_1": {
    "title": "Decorator to Time Function Execution",
    "topic": "python syntax",
    "difficulty": "moderate",
    "function": "timeit",
    "inputs": [
      "func: Callable"
    ],
    "return": "Callable",
    "statement": "Implement a decorator @timeit that measures and prints the execution time of the decorated function. The decorator should return the function’s original return value.",
    "sample_input": "@timeit\ndef compute():\n    total = sum(range(10**6))\n    return total\ncompute()",
    "sample_output": "compute took 0.01 seconds (and returns the sum value)"
  },
  "python_syntax_hard_1": {
    "title": "Metaclass to Enforce Singleton Pattern",
    "topic": "python syntax",
    "difficulty": "hard",
    "function": "SingletonMeta",
    "inputs": [],
    "return": "class with metaclass",
    "statement": "Write a metaclass SingletonMeta so that any class using it as its metaclass will be a singleton. Every time you instantiate the class, you receive the same instance.",
    "sample_input": "class MyClass(metaclass=SingletonMeta):\n    pass\na = MyClass()\nb = MyClass()",
    "sample_output": "a is b → true"
  },
  "loops_easy_1": {
    "title": "Sum of 1 to N",
    "topic": "loops",
    "difficulty": "easy",
    "function": "sum_to_n",
    "inputs": [
      "n: int"
    ],
    "return": "int",
    "statement": "Given an integer n, return the sum of all integers from 1 to n (inclusive) using a loop.",
    "sample_input": "n = 5",
    "sample_output": "15"
  },
  "loops_moderate_1": {
    "title": "Print Zigzag Pattern",
    "topic": "loops",
    "difficulty": "moderate",
    "function": "zigzag",
    "inputs": [
      "n: int"
    ],
    "return": "list[str]",
    "statement": "Given a positive integer n, return a list of strings representing an n×n zigzag pattern of '*' and spaces. For example, n = 5:\n*   *\n * * \n  *  \n * * \n*   *",
    "sample_input": "n = 3",
    "sample_output": "[\"* *\",\" * \",\"* *\"]"
  },
  "loops_hard_1": {
    "title": "Generate Combinations of Parentheses (Recursive/Loop Hybrid)",
    "topic": "loops",
    "difficulty": "hard",
    "function": "generate_parenthesis",
    "inputs": [
      "n: int"
    ],
    "return": "list[str]",
    "statement": "Given n pairs of parentheses, generate all combinations of well-formed parentheses using loops and/or recursion.",
    "sample_input": "n = 3",
    "sample_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
  },
  "functions_easy_1": {
    "title": "Recursive Fibonacci",
    "topic": "functions",
    "difficulty": "easy",
    "function": "fib",
    "inputs": [
      "n: int"
    ],
    "return": "int",
    "statement": "Given an integer n, return the nth Fibonacci number using a simple recursive approach (fib(0)=0, fib(1)=1).",
    "sample_input": "n = 4",
    "sample_output": "3"
  },
  "functions_moderate_1": {
    "title": "Memoized Fibonacci (Higher-Order Function)",
    "topic": "functions",
    "difficulty": "moderate",
    "function": "fib_memo",
    "inputs": [
      "n: int"
    ],
    "return": "int",
    "statement": "Rewrite the Fibonacci function using memoization (lru_cache) or a custom dictionary to improve the time complexity to O(n).",
    "sample_input": "n = 30",
    "sample_output": "832040"
  },
  "functions_hard_1": {
    "title": "Decorator with Arguments",
    "topic": "functions",
    "difficulty": "hard",
    "function": "repeat",
    "inputs": [
      "num_times: int"
    ],
    "return": "Callable",
    "statement": "Implement a decorator factory repeat(num_times) that takes an integer num_times and returns a decorator. When applied to a function, it runs the function num_times times and returns a list of results.",
    "sample_input": "@repeat(3)\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\ngreet(\"Alice\")",
    "sample_output": "[\"Hello, Alice!\", \"Hello, Alice!\", \"Hello, Alice!\"]"
  },
  "oop_easy_1": {
    "title": "Define a Rectangle Class",
    "topic": "OOP",
    "difficulty": "easy",
    "function": "Rectangle",
    "inputs": [
      "length: float",
      "width: float"
    ],
    "return": "class with methods",
    "statement": "Create a class Rectangle with methods: area() returns length × width, and perimeter() returns 2 × (length + width).",
    "sample_input": "rect = Rectangle(3, 4)",
    "sample_output": "rect.area() → 12, rect.perimeter() → 14"
  },
  "oop_moderate_1": {
    "title": "Implement a Stack Class with O(1) min() Method",
    "topic": "OOP",
    "difficulty": "moderate",
    "function": "StackWithMin",
    "inputs": [],
    "return": "class with methods",
    "statement": "Implement a stack that, in addition to push, pop, and top, has a method min() returning the minimum element in the stack in O(1) time.",
    "sample_input": "s = StackWithMin(); s.push(5); s.push(3); s.push(7); s.min(); s.pop(); s.min();",
    "sample_output": "[3, 3]"
  },
  "oop_hard_1": {
    "title": "Design a Least Recently Used (LRU) Cache",
    "topic": "OOP",
    "difficulty": "hard",
    "function": "LRUCache",
    "inputs": [
      "capacity: int"
    ],
    "return": "class with methods",
    "statement": "Design an LRU (Least Recently Used) cache data structure supporting get(key) and put(key, value) in O(1) time. When the cache reaches its capacity, evict the least recently used item before inserting a new item.",
    "sample_input": "cache = LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1); cache.put(3, 3); cache.get(2); cache.put(4, 4); cache.get(1); cache.get(3); cache.get(4);",
    "sample_output": "[1, -1, -1, 3, 4]"
  }
}