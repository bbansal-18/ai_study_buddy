"""
routes/chat_routes.py

Defines the Flask Blueprint and HTTP route for the AI-powered chat endpoint.
This endpoint accepts a user query, sends it to the OpenAI API with a system prompt
tailored for computer science tutoring, and returns a strictly JSON-formatted response
with metadata (validity, topic, keywords) and an answer.

Route:
    POST /chat
        Request JSON: { "query": "<user question>" }
        Response JSON (on success): {
            "valid": <bool>,
            "reason": <string or null>,
            "topic": <string>,
            "answer": <string>,
            "keywords": <list of strings>
        }
        Error Responses:
            400 Bad Request   -> missing or empty query
            502 Bad Gateway   -> AI response was not valid JSON
            500 Internal Error-> any other exception
"""

from flask import Blueprint, request, jsonify
import json
from openai import OpenAI

# Create a Blueprint for chat-related routes
chat_bp = Blueprint('chat_bp', __name__)

# Initialize the OpenAI client (expects OPENAI_API_KEY in environment)
client = OpenAI()

# System prompt guiding the AI to respond in a strict JSON schema
SYSTEM_PROMPT = """
You are an expert computer science and programming tutor assistant. Your job is to interpret each 
student query in the broad context of computer science, AI, and software development—and whenever 
possible, connect it to programming concepts or techniques.

Given a user query, you must respond **only** in JSON with these fields:

- **valid**: `true` if the query is on-topic (related even loosely to CS/programming/data structures/algorithms), otherwise `false`.
- **reason**: `null` if valid; otherwise, a brief explanation of why it's off-topic.
- **topic**: if valid, one of [recursion, dynamic programming, graphs, linked lists, arrays, tree data structure,
            sorting, searching, hashmaps, stacks, queues, greedy algorithms,
            python syntax, loops, functions, OOP]. If you detect a programming concept not in that list but still relevant, use `"unknown"`.
- **answer**:
    - If **topic** is in the list above, prioritize a deeper, code-oriented response (e.g., snippet patterns or complexity notes).
    - If **valid** but **topic** is `"unknown"`, give a concise (1-2 sentence) response focused on programming, even if the question was phrased generally.
    - If **valid** is `false`, set **answer** to `null`.
- **keywords**: an array of the most important terms from your **answer**.

**Special guidance:**
1. Always try to map the user's question to a programming or algorithmic concept.
2. If there's **any** hint of a programming angle (even indirectly), treat it as on-topic and choose the closest relevant topic.
3. Only mark `valid: false` when the query truly has no plausible connection to programming/CS.
4. For topics in `[recursion, dynamic programming, graphs, …, OOP]`, prioritize a deeper, code-oriented response.
"""


@chat_bp.route('/chat', methods=['POST'])
def chat():
    """
    POST /chat
    ------------
    Accepts a JSON payload with a user query and returns a structured JSON response
    generated by the OpenAI API according to the tutor assistant schema.

    Request JSON:
        {
            "query": "<string>"
        }

    Returns:
        200 OK      -> JSON object with keys: valid, reason, topic, answer, keywords
        400 Bad     -> {"error": "Missing 'query' in request body"}
        502 Bad     -> {"error": "Failed to parse model response as JSON", "raw_response": "<string>"}
        500 Internal-> {"error": "<exception message>"}
    """
    # Extract the 'query' field from incoming JSON and trim whitespace
    user_query = request.json.get("query", "")
    user_query = user_query.strip() if isinstance(user_query, str) else ""

    # Validate presence of user query
    if not user_query:
        return jsonify({"error": "Missing 'query' in request body"}), 400

    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages= [
                {"role": "system", "content": SYSTEM_PROMPT},
                {"role": "user",   "content": user_query}
            ],
            temperature=0.7
        )

        # Extract and clean the assistant's raw content
        content = resp.choices[0].message.content.strip()
        
        response_json = json.loads(content)

        return jsonify(response_json), 200

    except json.JSONDecodeError:
        # The AI's response wasn't valid JSON—return raw content for debugging
        return jsonify({
            "error": "Failed to parse model response as JSON",
            "raw_response": content
        }), 502

    except Exception as e:
        # Catch-all for any other errors (e.g., network, API key issues)
        return jsonify({"error": str(e)}), 500
